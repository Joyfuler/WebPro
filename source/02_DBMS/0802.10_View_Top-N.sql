-- [X] VIEW, IN-LINE VIEW, ★TOP-N★
DROP TABLE EMP1;
CREATE TABLE EMP1 AS SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, DEPTNO FROM EMP; --인사팀만 볼 수 있는 데이터. 급여데이터를 뻄
-- 누군가 입사한다면? EMP1 데이터를 업데이트한다 하더라도 EMP에는 반영되지 않는 문제가 있음.
SELECT * FROM USER_TABLES WHERE TABLE_NAME LIKE 'EMP%';
INSERT INTO EMP1 (EMPNO, ENAME, DEPTNO) VALUES (1111,'홍',40);
SELECT * FROM EMP1; --홍검색o
SELECT * FROM EMP; -- 홍검색X
DROP TABLE EMP1;
-- 1. VIEW : 위와 같은 문제를 해결하기 위해 만들어진 가상 테이블. 1) 단순뷰, 2)복합뷰
-- 실제 테이블은 따로 존재. 물리적인 저장공간이 X
-- (1) 단순뷰
CREATE OR REPLACE VIEW EMPV0
AS (SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, DEPTNO FROM EMP);
SELECT * FROM EMPV0;
-- EMPV0을 수정하면 EMP에도 적용됨.
SELECT * FROM USER_TABLES WHERE TABLE_NAME LIKE 'EMP%'; -- 이와같이 검색해도 EMPV0은 찾을 수 없음.
SELECT * FROM USER_VIEWS; -- 이와 같이 VIEWS로 검색해야 찾을 수 있음.
INSERT INTO EMPV0 VALUES (1111,'홍','MANAGER',NULL,SYSDATE,40); -- VIEW에 INSERT함
SELECT * FROM EMP; -- EMP에도 추가한 데이터가 들어가는 것을 확인할 수 있음.
ROLLBACK; -- INSERT, DELETE등은 롤백이 가능함. (COMMIT 사용시 확정)

CREATE OR REPLACE VIEW EMPV0
AS SELECT * FROM EMP WHERE DEPTNO = 30; -- SALES 부서의 데이터 (특정 행)만 가져오려면?
SELECT * FROM EMPV0;
INSERT INTO EMPV0 VALUES (111,'홍','MANAGER',NULL,SYSDATE,NULL,NULL,30);
SELECT * FROM EMP;
INSERT INTO EMPV0 (EMPNO, ENAME, DEPTNO) VALUES (112, '박', 40); -- VIEW는 30번만 가능하도록 설정하였음에도 만들어짐.
-- EMP에서는 이를 확인할 수 있으나, EMPV0에서는 확인할 수 없음.
UPDATE EMP SET EMPNO=1111 WHERE ENAME = '홍';
UPDATE EMP SET EMPNO=1112 WHERE ENAME = '박';
-- 만일 30번 열람만 가능하다면, 30번 부서 인원만 INSERT 가능하도록 권한을 조정하고 싶다면?
-- WITH CHECK OPTION 추가 : 뷰의 조건에 해당되는 데이터만 삽입, 수정, 삭제 가능
-- WITH READ ONLY 추가: 읽기 전용. 테이블 수정이 불가능함.

CREATE OR REPLACE VIEW EMPV0
AS SELECT * FROM EMP WHERE DEPTNO = 30
WITH CHECK OPTION;
INSERT INTO EMPV0 (EMPNO, ENAME, DEPTNO) VALUES (112, '박', 40); -- 40번 부서가 CHECK-OPTION에 걸려 오류남.
INSERT INTO EMPV0 (EMPNO, ENAME, DEPTNO) VALUES (1113,'이',30);
DELETE FROM EMPV0 WHERE DEPTNO = 20; -- 0개행 삭제. 출력이 안 되므로 지워지지도 않음.

-- 읽기 전용 뷰 만드는 법. (WITH READ ONLY 혹은 추가하지 않아도 읽기 전용이 되는 경우)
CREATE OR REPLACE VIEW EMPV0
AS SELECT * FROM EMP
WITH READ ONLY; -- 당연히 다음과 같이 생성 가능.
DELETE FROM EMPV0 WHERE EMPNO < 2000; -- READ-ONLY VIEW 에러.
DELETE FROM EMP WHERE EMPNO <2000;
COMMIT;

CREATE OR REPLACE VIEW EMPV0 AS SELECT ENAME, JOB FROM EMP;
-- 단순뷰 생성시에도 NOT NULL (PK인 EMPNO 등) 필드를 넣지 않은 경우 사실상 읽기 전용이 됨.
SELECT * FROM EMPV0;
INSERT INTO EMPV0 VALUES ('홍길', 'MANAGER'); 
-- 사번, MGR, SAL, COMM,DEPTNO는 자동으로 NULL이 입력. 그러나 EMPNO가 PRIMARY KEY이므로 NULL이 불가

-- (2) 복합뷰 : 2개 이상의 테이블로 구성한 뷰. 1개의 테이블로 가상의 필드를 이용한 뷰, DML문 제한적 사용
-- ① 2개 이상의 테이블 구성
CREATE OR REPLACE VIEW EMPV0 
AS (SELECT EMPNO, ENAME, JOB, DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO);
SELECT * FROM EMPV0; -- 마치 부서이름이 있는 것처럼 합치기가 가능. 단 INSERT 불가.
INSERT INTO EMPV0 VALUES (1111,'홍','MANAGER','SALES'); -- 에러. 조인을 사용한 VIEW로는 INSERT를 사용할 수 없고, SELECT만 가능함.

-- ① 존재하지 않던 가상의 필드 (연봉)를 만듬.
CREATE OR REPLACE VIEW EMPV0 
AS SELECT EMPNO, ENAME, SAL, SAL*12 연봉 FROM EMP;
SELECT * FROM EMPV0;
INSERT INTO EMPV0 VALUES (1111, '홍', 100,1200); -- 에러. 가상의 필드에는 INSERT할 수 없고, SELECT만 가능함.
-- ★★★★ 복합뷰 사용시에는 필드의 이름이 중복되지 않도록 하고, 이름에 * 등 특수문자가 들어가지 않도록 하자. _ 등은 가능
CREATE OR REPLACE VIEW EMPV0 (EMPNO, ENAME, SAL, YEAR_SAL) -- 별칭만 따로 뺼 수 있음
AS SELECT EMPNO, ENAME, SAL, SAL*12 FROM EMP;
SELECT * FROM EMPV0; --이와 같이 만들면 SAL*12값이 YEAR_SAL 테이블로 들어감.

CREATE OR REPLACE VIEW EMPV0 (DEPTNO, AVG) -- 그룹함수와 단일필드를 함께 넣어서 만들기 위해 GROUP BY 사용하였음
AS SELECT DEPTNO, ROUND(AVG(SAL)) FROM EMP GROUP BY DEPTNO;
SELECT * FROM EMPV0;


-- 2. 인라인뷰 (IN-LINE VIEW) : FROM절의 서브쿼리를 인라인뷰라 하며, FROM절에 오는 서브쿼리가 일시적으로 VIEW처럼 작용
-- EX. 급여가 2000 을 초과하는 사원의 평균급여
SELECT AVG(SAL) FROM EMP WHERE SAL >2000; -- 기본방법
SELECT AVG(SAL) FROM (SELECT SAL FROM EMP WHERE SAL>2000); -- FROM에 서브쿼리 활용함. 
-- 여기에서 괄호 안에 있는 SAL>2000인 급여의 값이 일시적으로 VIEW로 만들어진 것.

-- EX. 부서 평균 급여보다 급여가 높은 사원의 사번, 이름, 급여 부서번호 출력
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP E
WHERE SAL > ROUND((SELECT AVG(SAL) FROM EMP WHERE DEPTNO = E.DEPTNO)); -- 본래는 WHERE절에 서브쿼리를 넣어서 해결하였음.

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP; -- A
SELECT DEPTNO, AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO; -- B. A와 B를 조인함.
SELECT EMPNO, ENAME, SAL, E.DEPTNO, ROUND(AVGSAL) 
    FROM EMP E, (SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) B WHERE E.DEPTNO=B.DEPTNO AND SAL>AVGSAL;
    -- FROM을 우선 가져오므로, ROUND(AVGSAL)로 입력)

SELECT EMPNO, ENAME, SAL, E.DEPTNO, AVGSAL
FROM EMP E, (SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) B WHERE E.DEPTNO=B.DEPTNO AND SAL> AVGSAL;
-- FROM의 AVGSAL과 SELECT의 AVGSAL 맞춰줘야 하는듯...?
    
-- 3. TOP-N 구문 (TOP 1~10등, 11등~20등, ...) 순위대로 일부 출력하게 만듬.
-- ROWNUM(테이블로부터 가져온 순서)와 INLINE-VIEW를 이용한 TOP-N 구문
SELECT ROWNUM, EMPNO, ENAME FROM EMP; -- 등록순서로 ROWNUM 매김
SELECT ROWNUM, EMPNO, ENAME FROM EMP WHERE DEPTNO = 20;
SELECT ROWNUM, ENAME, SAL FROM EMP ORDER BY SAL; -- 화면 출력은 SAL 순서대로, 그러나 ROWNUM은 가져온 순서를 표시하므로 정렬되지 않음.
-- FROM절의 해석이 가장 먼저이므로, FROM에서 SORT하도록 하게 하면 됨.
-- 1등부터 꼴찌까지. 그런데 1~10, 11~20 순으로 나누려면?
SELECT ROWNUM, ENAME, SAL 
FROM (SELECT ENAME, SAL FROM EMP ORDER BY SAL DESC) 
WHERE ROWNUM BETWEEN 1 AND 10;
-- 이거까진 되는데, 6~10은?
SELECT ROWNUM, ENAME, SAL 
FROM (SELECT ENAME, SAL FROM EMP ORDER BY SAL DESC) 
WHERE ROWNUM BETWEEN 6 AND 10;
-- 출력되지 않음. ROWNUM을 WHERE절에서 물어봤기 때문. TOP-N구문을 만들 때에는 전체를 다시 덮어줘야 함.
SELECT ROWNUM RN, ENAME, SAL FROM 
(SELECT ENAME, SAL FROM EMP ORDER BY SAL DESC); -- 급여의 순서를 출력한 서브쿼리. ROWNUM의 전체가 나옴.
SELECT ROWNUM, RN, ENAME, SAL 
FROM (SELECT ROWNUM RN, ENAME, SAL FROM (SELECT ENAME, SAL FROM EMP ORDER BY SAL)) 
WHERE RN BETWEEN 6 AND 10;
-- RN이라는 랭킹을 새로 만들어줌. 

SELECT ROWNUM, RN, ENAME, SAL 
FROM (SELECT ROWNUM RN, ENAME, SAL FROM (SELECT ENAME, SAL FROM EMP ORDER BY SAL)) 
WHERE RN BETWEEN 10 AND 15;

-- EX. 이름순(ABC순)으로 6번째부터 10번째까지 사원의 모든 정보 출력
SELECT * FROM (SELECT ROWNUM RN, E.* FROM (SELECT * FROM EMP ORDER BY ENAME) E)
WHERE RN BETWEEN 5 AND 10;

-- EX. 입사최신순...
SELECT * FROM (SELECT ROWNUM RN, E.* FROM (SELECT * FROM EMP ORDER BY HIREDATE) E)
WHERE RN BETWEEN 5 AND 10;


--★★★★★ 연습문제 ★★★★★
-- 1. 부서명과 사원명을 출력하는 용도의 뷰, DNAME_ENAME_VU 를 작성하시오
CREATE OR REPLACE VIEW DNAME_ENAME_VU
AS SELECT DNAME, ENAME FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;
SELECT * FROM DNAME_ENAME_VU;

-- 2. 사원명과 직속상관명을 출력하는 용도의 뷰, WORKER_MANAGER_VU를 작성하시오
CREATE OR REPLACE VIEW WORKER_MANAGER_VU (ENAME, SANGSANAME)
AS SELECT W.ENAME ENAME1, M.ENAME ENAME2 FROM EMP W, EMP M
WHERE W.MGR = M.EMPNO;
SELECT * FROM WORKER_MANAGER_VU;

-- 3. 부서별 급여합계 등수를 출력하시오(부서번호, 급여합계, 등수)
SELECT DEPTNO, SUM(SAL) SUMSAL FROM EMP GROUP BY DEPTNO ORDER BY SUMSAL DESC;
SELECT ROWNUM RANK, DEPTNO, SUMSAL 
FROM (SELECT DEPTNO, SUM(SAL) SUMSAL FROM EMP GROUP BY DEPTNO ORDER BY SUMSAL DESC);

-- 3-1. 부서별 급여합계 등수가 2~3등인 부서번호, 급여합계, 등수를 출력하시오. ? 친구 출제
SELECT ROWNUM, E.* 
FROM (SELECT ROWNUM RANK, DEPTNO, SUMSAL FROM 
(SELECT DEPTNO, SUM(SAL) SUMSAL FROM EMP GROUP BY DEPTNO ORDER BY SUMSAL DESC))  E
WHERE RANK BETWEEN 2 AND 3;
-- 가상테이블에는 괄호 등 특수문자를 넣을 수 없으므로 반드시 alias를 통해 이름을 재정의해줘야함.
    
-- E.*를 쓰고 싶다면, 가장 바깥의 FROM의 이름을 따로 정해주고, 그 이름으로 .* 을 해주자.

-- 4. 사원테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 사원 순으로 정렬하시오
SELECT EMPNO, ENAME, HIREDATE FROM EMP ORDER BY HIREDATE DESC;

-- 5. 사원테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 사원 5명을 출력하시오
SELECT ROWNUM, A.*
FROM (SELECT EMPNO, ENAME, HIREDATE FROM EMP ORDER BY HIREDATE DESC) A
WHERE ROWNUM <=5;

-- 6. 사원 테이블에서 사번, 사원명, 입사일을 최신부터 오래된 순으로 6번째로 늦은 사원부터 10번째 사원까지 출력
SELECT * 
FROM (SELECT ROWNUM RN, EMPNO, ENAME, HIREDATE 
FROM (SELECT EMPNO, ENAME, HIREDATE FROM EMP ORDER BY HIREDATE DESC))
WHERE RN BETWEEN 6 AND 10;