-- [VI] Sub Query: 메인 Query (SQL) 안에 QUERY (SQL문)이 내포되어 있는 것.
-- ★ 1. 서브 쿼리 개념
-- 서브쿼리가 필요한 이유?
-- ex. 급여를 제일 많이 받는 사람의 모든 정보
SELECT EMPNO, ENAME FROM EMP WHERE SAL= (SELECT MAX(SAL) FROM EMP); -- 서브쿼리로 둠
SELECT * FROM EMP WHERE SAL = (SELECT MAX(SAL) FROM EMP); -- 메인쿼리, 서브쿼리
-- 실행 순서는 서브 쿼리 우선, 이후 메인쿼리 실행됨.

-- 서브 쿼리의 종류 (1) 단일행 서브쿼리 (서브쿼리의 실행결과가 단일행인 경우) 연산자를 사용. =
-- SELECT MAX(SAL) FROM EMP가 5천으로 값이 1개라면 즉시 =, >=, <=, != 등으로 값을 비교할 수 있음.
-- EX. SCOTT과 동일한 부서에서 근무하는 사원의 일므, 급여
SELECT ENAME, SAL FROM EMP WHERE DEPTNO =
(SELECT DEPTNO FROM EMP WHERE ENAME = 'SCOTT')
AND ENAME != 'SCOTT';
     
-- 서브 쿼리의 종류 (2) 다중행 서브쿼리 (서브쿼리의 실행 결과가 2행이상) IN, ALL, >ANY(SOME), EXISTS
-- EX. SCOTT이나 KING과 동일한 부서에서 근무하는 사원의 이름, 급여
-- 우선 서브쿼리를 작성..SCOTT과 KING의 부서번호를 출력
SELECT DEPTNO FROM EMP WHERE ENAME IN ('SCOTT', 'KING'); -- 다중형 서브쿼리. 10과 20값을 각각 가짐
SELECT ENAME, SAL
FROM EMP
WHERE DEPTNO = 
(SELECT DEPTNO FROM EMP WHERE ENAME IN ('SCOTT', 'KING')); -- 오류. = 연산자를 사용 불가
-- 이 경우는 = 대신 IN을 사용하여 해결
SELECT ENAME, SAL
FROM EMP
WHERE DEPTNO IN 
(SELECT DEPTNO FROM EMP WHERE ENAME IN ('SCOTT','KING'));

-- ★ 2. 다중 쿼리 개념
-- SCOTT과 동일한 근무지에서 근무하는 사원의 모든 정보
-- DALLAS, 50번부서 근무지에 일하는 사람을 추가하려면? -- 우선 DEPT에 값을 추가해야 함... LOC은 DEPT에 있으므로..
INSERT INTO DEPT VALUES  (50, 'IT', 'DALLAS');
INSERT INTO EMP (EMPNO, ENAME, DEPTNO) VALUES (8000,'홍길동',50); -- EMPNO, ENAME, DEPTNO만 값을 넣어 생성
SELECT EMP.*, ENAME, LOC FROM EMP,DEPT 
WHERE EMP.DEPTNO = DEPT.DEPTNO 
AND LOC = (SELECT LOC FROM EMP, DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO AND ENAME = 'SCOTT');
ROLLBACK; -- 데이터 추가, 삭제, 수정, 검색 등을 취소..
-- COMMIT; 데이터를 실제로 오라클에 INSERT하여 저장하는 것.
-- EX2. 최초 입사 직원 이름과 최초 입사일 출력.. 먼저 최초 입사일을 출력
SELECT ENAME, HIREDATE FROM EMP 
WHERE HIREDATE = (SELECT MIN(HIREDATE) FROM EMP);
-- EX3. 최근 입사 직원 이름과 최근 입사일
SELECT ENAME, HIREDATE FROM EMP 
WHERE HIREDATE = (SELECT MAX(HIREDATE) FROM EMP);
-- EX4. 최초 입사 직원 이름과 최초 입사일, 최근 입사 직원 이름과 최근 입사일
SELECT E1.ENAME, E1.HIREDATE, E2.ENAME, E2.HIREDATE
FROM EMP E1, EMP E2
WHERE E1.HIREDATE = (SELECT MIN(HIREDATE) FROM EMP) 
AND E2.HIREDATE = (SELECT MAX(HIREDATE) FROM EMP);
-- SELECT에도 서브쿼리를 추가할 수 있음. 최초입사자를 구하는 SELECT문을 SELECT 안에 넣음
SELECT
    (SELECT ENAME FROM EMP WHERE HIREDATE = (SELECT MIN(HIREDATE) FROM EMP)) 최초입사자,
    (SELECT MIN(HIREDATE) FROM EMP) 최초입사일,
    (SELECT ENAME FROM EMP WHERE HIREDATE = (SELECT MAX(HIREDATE) FROM EMP )) 최근입사자,
    (SELECT MAX (HIREDATE) FROM EMP) 최근입사일
    FROM DUAL;
    
-- EX5. SCOTT과 같은 부서에 근무하는 사람들의 급여합
SELECT SUM(SAL) FROM EMP 
WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME = 'SCOTT');

-- EX6. SCOTT과 동일한 JOB을 가진 사원의 모든 필드
SELECT JOB FROM EMP WHERE ENAME = 'SCOTT'; --서브쿼리
SELECT * FROM EMP WHERE JOB = (SELECT JOB FROM EMP WHERE ENAME = 'SCOTT'); -- 메인쿼리

-- EX7. 서브쿼리OR JOIN 모두 가능.. 달라스에 근무하는 사원의 이름과 부서번호를 출력
SELECT DEPTNO FROM DEPT WHERE LOC = 'DALLAS';
SELECT ENAME, DEPTNO FROM EMP 
WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC = 'DALLAS');
SELECT ENAME, E.DEPTNO FROM EMP E, DEPT D 
WHERE E.DEPTNO = D.DEPTNO AND LOC = 'DALLAS';

-- EX8. 'KING'이 직속상사인 사원의 이름과 급여 (서브쿼리, SELFJOIN)
SELECT EMPNO FROM EMP WHERE ENAME = 'KING';
SELECT ENAME, SAL FROM EMP WHERE MGR = (SELECT EMPNO FROM EMP WHERE ENAME = 'KING');
SELECT W.EMPNO, W.ENAME, W.SAL FROM EMP W, EMP M
WHERE W.MGR = M.EMPNO AND M.ENAME = 'KING';

-- EX9. 평균급여 이하로 받는 사원의 이름과 급여를 출력
SELECT ROUND(AVG(SAL),1) FROM EMP; -- 서브쿼리
SELECT ENAME, SAL FROM EMP 
WHERE SAL <= (SELECT ROUND(AVG(SAL),1) FROM EMP);

-- EX10. 평균급여 이하로 받는 사원의 이름과 급여와 평균급여를 출력 (소숫점1자리)
SELECT ROUND(AVG(SAL),1) FROM EMP;
SELECT ENAME, SAL, ROUND((SELECT AVG(SAL) FROM EMP),1) 
FROM EMP WHERE SAL <= (SELECT ROUND(AVG(SAL),1) FROM EMP);

-- EX11. 평균급여 이하로 받는 사원의 이름, 급여, 평균급여와의 차이를 출력
SELECT AVG(SAL) FROM EMP; -- 서브
SELECT ENAME, SAL, ROUND(ABS(SAL - (SELECT AVG(SAL) FROM EMP))) CHAYI
FROM EMP WHERE SAL <= (SELECT AVG(SAL) FROM EMP);


-- 단일행 다중열 서브쿼리
-- SCOTT의 JOB과 부서번호가 같은 직원의 모든 필드를 출력.. 
SELECT * FROM EMP WHERE JOB = (SELECT JOB FROM EMP WHERE ENAME = 'SCOTT') AND 
DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME = 'SCOTT'); 
-- 으로도 할 수는 있으나 매우 복잡.. 이런 경우는 다중열 서브쿼리를 사용함.
SELECT * FROM EMP
WHERE (JOB, DEPTNO) = (SELECT JOB, DEPTNO FROM EMP WHERE ENAME = 'SCOTT');
-- WHERE절에 (JOB,DEPTNO를 넣고, SELECT 절에 JOB,DEPTNO를 한번에 넣어줌). 단, 순서를 반드시 지켜줘야 할 것.

-- ★ 3. 다중행서브쿼리 (IN, ALL, ANY(=SOME), EXITSTS 등을 사용...
-- (1) IN 연산자 - 서브쿼리의 결과 중 하나라도 일치하면 참
-- EX. 부서별 입사일이 가장 늦은 사람의 이름, 입사일, 부서번호
SELECT DEPTNO, MAX(HIREDATE) FROM EMP GROUP BY DEPTNO; -- 다중행 다중열 서브쿼리.. 여기서 이름을 출력하고 싶어서?
SELECT DEPTNO, MAX(HIREDATE), ENAME FROM EMP GROUP BY DEPTNO, ENAME; -- 이렇게 하는 경우 14명이 모두 출력되므로 의미가 없음.
SELECT ENAME, HIREDATE, DEPTNO
FROM EMP
WHERE (DEPTNO, HIREDATE) IN (SELECT DEPTNO, MAX(HIREDATE) FROM EMP GROUP BY DEPTNO); -- 둘 중 하나라도 같으면 출력됨.
-- 이렇게 다중행 다중열인 경우는 = 대신에 IN을 사용할 것.
-- EX. 급여가 3000 이상 받는 사원이 소속된 부서의 사원들의 모든 필드
SELECT DEPTNO FROM EMP WHERE SAL >= 3000; -- 서브쿼리
SELECT * FROM EMP
WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE SAL >= 3000 GROUP BY DEPTNO);

-- (2) ALL : 서브쿼리 결과가 모두 만족하면 참
-- EX. 30번 부서 직원 모든 급여보다 큰 직원의 모든 필드
SELECT SAL FROM EMP WHERE DEPTNO = 30; -- 서브쿼리, 950,1250,1500,1600,2850
SELECT * FROM EMP WHERE SAL > ALL (SELECT SAL FROM EMP WHERE DEPTNO = 30);
-- 30번 부서직원의 최대 급여보다 급여가 큰 직원의 모든 필드 출력
SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30;
SELECT * FROM EMP WHERE SAL > (SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30);

-- (3) ANY(=SOME), 서브쿼리 조건의 결과가 하나 이상 만족하면 참
-- 30번 부서 직원 한명 만이라도 급여가 큰 직원의 모든 필드
SELECT SAL FROM EMP WHERE DEPTNO = 30;
SELECT * FROM EMP WHERE SAL > ANY (SELECT SAL FROM EMP WHERE DEPTNO = 30); -- 다중행 서브쿼리 (ANY) 이용
SELECT * FROM EMP WHERE SAL > (SELECT MIN(SAL) FROM EMP WHERE DEPTNO =30); -- 단일행 서브쿼리 이용

-- (4) EXISTS : 서브쿼리 결과가 존재하면 참. EXISTS의 경우 서브쿼리가 단독 (F9) 실행되지 않는 것이 특징임.
-- 직속부하가 있는 직원들의 사번, 이름, 급여
SELECT EMPNO, ENAME, SAL FROM EMP M WHERE EXISTS (SELECT * FROM EMP WHERE M.EMPNO = MGR); --  EXISTS 서브쿼리를 이용
SELECT DISTINCT E2.EMPNO, E2.ENAME, E2.SAL FROM EMP E1, EMP E2 WHERE  E1.MGR = E2.EMPNO; -- 셀프조인을 이용
-- 직속부하가 없는 직원들의 사번, 이름, 급여
SELECT EMPNO, ENAME, SAL FROM EMP M WHERE NOT EXISTS (SELECT * FROM EMP WHERE M.EMPNO = MGR); -- 존재X시 NOT을 붙여서 출력
SELECT E1.ENAME, E2.EMPNO, E2.ENAME, E2.SAL
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO AND E1.MGR IS NULL; -- 셀프조인 + 아우터조인까지 활용해야하므로 불편

-- 탄탄1. 부서별로 가장 급여를 많이 받는 사원의 모든 정보를 출력(IN 연산자 이용)
SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO; -- 서브쿼리
SELECT * FROM EMP E, DEPT D, SALGRADE WHERE E.DEPTNO = D.DEPTNO AND SAL BETWEEN LOSAL AND HISAL AND (E.DEPTNO,E.SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO)
ORDER BY E.DEPTNO;
-- 다중행이므로 IN을 사용해야...

-- 탄탄2. 직급(JOB)이 MANAGER인 사람의 속한 부서의 부서 번호와 부서명과 지역을 출력(IN)
SELECT * FROM DEPT
WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE JOB = 'MANAGER');

-- 탄탄3. 급여가 3000이상인 사람들 중 연봉 등급을 나누어서 해당 등급별 최고 급여를 받는 사람들의 사번, 이름, 직업, 입사일, 급여, 급여등급을 출력
SELECT EMPNO, ENAME, JOB, HIREDATE, SAL, GRADE
FROM EMP, SALGRADE
WHERE SAL BETWEEN LOSAL AND HISAL
AND SAL >= ANY (SELECT SAL FROM EMP WHERE SAL =3000 GROUP BY SAL,GRADE);

-- 탄탄4. 응용심화 : 입사일 분기별로 가장 높은 연봉을 받는 사람들의 분기, 사번, 이름, JOB, 상사사번, 입사일, 급여, 상여를 출력하세요
SELECT TO_CHAR(HIREDATE,'Q') BUNGI, EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM
FROM EMP
WHERE SAL IN (SELECT MAX(SAL) FROM EMP GROUP BY TO_CHAR(HIREDATE,'Q'));


-- 탄탄5. 급여가 3000미만인 사람 중에 가장 최근에 입사한 사람의 사원번호와 이름, 급여, 입사일을 출력
SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE HIREDATE = (SELECT MAX(HIREDATE) FROM EMP WHERE SAL <3000);

-- 탄탄6. SALESMAN 모든 사원들 보다 급여를 많이 받는 사원들의 이름과 급여와 직급(담당 업무)를 출력하되 영업 사원은 출력하지 않는다.(ALL이용)
SELECT ENAME, SAL, JOB 
FROM EMP
WHERE SAL > ALL (SELECT SAL FROM EMP WHERE JOB = 'SALESMAN')
AND JOB != 'SALESMAN';

SELECT ENAME, SAL, JOB
FROM EMP
WHERE  SAL > (SELECT MAX(SAL) FROM EMP WHERE JOB = 'SALESMAN');

-- 탄탄7. SALESMAN 일부 어떤 한 사원보다 급여를 많이 받는 사원들의 이름과 급여와 직급(담당 업무)를 출력하되 영업 사원도 출력(ANY)
SELECT ENAME, SAL, JOB
FROM EMP
WHERE SAL >= ANY (SELECT SAL FROM EMP WHERE JOB = 'SALESMAN');

SELECT ENAME, SAL, JOB
FROM EMP
WHERE  SAL > (SELECT MIN(SAL) FROM EMP WHERE JOB = 'SALESMAN');

-- ★ 총 연습문제 

--1. 사원테이블에서 가장 먼저 입사한 사람의 이름, 급여, 입사일
SELECT ENAME, SAL, HIREDATE FROM EMP 
WHERE HIREDATE = (SELECT MIN(HIREDATE) FROM EMP);

-- 2. 회사에서 가장 급여가 적은 사람의 이름, 급여
SELECT ENAME, SAL FROM EMP 
WHERE SAL = (SELECT MIN(SAL) FROM EMP);

-- 3. 회사 평균보다 급여를 많이 받는 사람의 이름, 급여, 부서코드
SELECT ENAME, SAL, DEPTNO FROM EMP 
WHERE SAL > (SELECT AVG(SAL) FROM EMP);

--4. 회사 평균 이하의 급여를 받는 사람의 이름, 급여, 부서명
SELECT ENAME, SAL, DNAME FROM EMP, DEPT 
WHERE EMP.DEPTNO = DEPT.DEPTNO AND SAL <=(SELECT AVG(SAL) FROM EMP);

--5. SCOTT보다 먼저 입사한 사람의 이름, 급여, 입사일, 급여 등급
SELECT ENAME, SAL, HIREDATE, GRADE 
FROM EMP, SALGRADE 
WHERE SAL BETWEEN LOSAL AND HISAL 
AND HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME = 'SCOTT');

--6. 5번(SCOTT보다 먼저 입사한 사람의 이름, 급여, 입사일, 급여 등급)에 부서명 추가하고 급여가 큰 순 정렬
SELECT ENAME, SAL, HIREDATE, GRADE, DNAME
FROM EMP, SALGRADE, DEPT
WHERE SAL BETWEEN LOSAL AND HISAL AND EMP.DEPTNO = DEPT.DEPTNO
AND HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME = 'SCOTT')
ORDER BY SAL DESC;

--7. BLAKE 보다 급여가 많은 사원들의 사번, 이름, 급여
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'BLAKE');

--8. MILLER보다 늦게 입사한 사원의 사번, 이름, 입사일
SELECT EMPNO, ENAME, HIREDATE
FROM EMP
WHERE HIREDATE > (SELECT HIREDATE FROM EMP WHERE ENAME = 'MILLER');

--9. 사원전체 평균 급여보다 급여가 많은 사원들의 사번, 이름, 급여
SELECT EMPNO, ENAME, SAL 
FROM EMP
WHERE SAL > (SELECT AVG(SAL) FROM EMP);

--10. CLARK와 같은 부서번호이며, 사번이 7698인 직원의 급여보다 많은 급여를 받는 사원의 사번, 이름, 급여
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME = 'CLARK')
AND SAL > (SELECT SAL FROM EMP WHERE EMPNO = 7698);

--11.  응용심화. CLARK와 같은 부서명이며, 사번이 7698인 직원의 급여보다 많은 급여를 받는 사원의 사번, 이름, 급여
SELECT EMPNO, ENAME, SAL
FROM EMP,DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO 
AND DNAME = 
(SELECT DNAME FROM DEPT,EMP 
WHERE DEPT.DEPTNO = EMP.DEPTNO 
AND ENAME = 'CLARK')
AND SAL > (SELECT SAL FROM EMP WHERE EMPNO = 7698);

--12. BLAKE와 같은 부서에 있는 모든 사원의 이름과 입사일자
SELECT ENAME, HIREDATE
FROM EMP
WHERE DEPTNO = 
(SELECT DEPTNO FROM EMP WHERE ENAME = 'BLAKE');

--13. 평균 급여 이상을 받는 모든 종업원에 대해서 사원번호와 이름 단 급여가 많은 순으로 출력)
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL >= (SELECT AVG(SAL) FROM EMP)
ORDER BY SAL DESC;

-- 14.  이름에 “T”가 있는 사원이 근무하는 부서에서 근무하는 모든 직원의 사원 번호,이름,급여(단 사번 순 출력)
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE ENAME LIKE '%T%')
ORDER BY EMPNO;

-- 15. 부서 위치가 Dallas인 모든 종업원에 대해 이름,업무,급여
SELECT ENAME, JOB, SAL
FROM EMP
WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE INITCAP(LOC) = 'Dallas');

-- 16. EMP 테이블에서 King에게 보고하는 모든 사원의 이름과 급여
SELECT E1.ENAME, E1.SAL
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO AND
E2.EMPNO = (SELECT EMPNO FROM EMP WHERE INITCAP(ENAME) = 'King');

-- 17. SALES부서 사원의 이름, 업무
SELECT ENAME, JOB, DEPTNO
FROM EMP
WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE DNAME = 'SALES');

-- 18. 월급이 부서 30의 최저 월급보다 높은 사원의 모든 필드
SELECT * FROM EMP
WHERE SAL > ANY (SELECT SAL FROM EMP WHERE DEPTNO=30);

-- 19.  FORD와 업무도 월급도 같은 사원의 모든 필드
SELECT * FROM EMP
WHERE (JOB, SAL) = (SELECT JOB,SAL FROM EMP WHERE ENAME = 'FORD')
AND ENAME != 'FORD';

-- 20. 이름이 JONES인 직원의 JOB과 같거나 FORD의 SAL 이상을 받는 사원의 정보를 이름, 업무, 부서번호, 급여
    -- 단, 업무별 알파벳 순, 월급이 많은 순으로 출력
SELECT ENAME, JOB, DEPTNO, SAL FROM EMP
WHERE JOB = (SELECT JOB FROM EMP WHERE ENAME = 'JONES') OR
SAL >= (SELECT SAL FROM EMP WHERE ENAME = 'FORD') ORDER BY JOB, SAL DESC;

-- 21. SCOTT 또는 WARD와 월급이 같은 사원의 정보를 이름,업무,급여
SELECT ENAME, JOB, SAL
FROM EMP
WHERE SAL IN (SELECT SAL FROM EMP WHERE ENAME = 'SCOTT' OR ENAME = 'WARD')
AND ENAME != 'SCOTT' AND ENAME != 'WARD';

-- 22. CHICAGO에서 근무하는 사원과 같은 업무를 하는 사원들의 이름,업무
SELECT ENAME, JOB, LOC
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
AND JOB IN (SELECT JOB FROM EMP,DEPT WHERE  EMP.DEPTNO = DEPT.DEPTNO AND LOC = 'CHICAGO');

-- 23. 부서 평균 월급보다 월급이 높은 사원을 사번, 이름, 급여, 부서번호
SELECT EMPNO, ENAME, SAL, E.DEPTNO
FROM EMP E
WHERE SAL >= (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = E.DEPTNO GROUP BY DEPTNO);
-- 사번, 이름, 급여, 부서번호, 해당 부서의 평균 급여
SELECT EMPNO, ENAME, SAL, DEPTNO, ROUND((SELECT AVG(SAL) FROM EMP WHERE DEPTNO = E.DEPTNO GROUP BY DEPTNO)) AVG
FROM EMP E
WHERE SAL > (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = E.DEPTNO);

-- 24. 업무별로 평균 월급보다 적은 월급을 받는 사원을 부서번호, 이름, 급여
SELECT EMPNO, ENAME, SAL, ROUND((SELECT AVG(SAL) FROM EMP WHERE JOB = E.JOB)) AVG
FROM EMP E
WHERE SAL < (SELECT AVG(SAL) FROM EMP WHERE JOB = E.JOB);

SELECT EMPNO, ENAME, E.SAL, JOB, ROUND((SELECT AVG(SAL) FROM EMP WHERE JOB = E.JOB)) AVG
FROM EMP E
WHERE SAL < (SELECT AVG(SAL) FROM EMP WHERE JOB = E.JOB);

-- 25. 적어도 한 명 이상으로부터 보고를 받을 수 있는 사원을 업무, 이름, 사번, 부서번호를 출력(단, 부서번호 순으로 오름차순 정렬)
SELECT DISTINCT M.JOB, M.ENAME, M.EMPNO, M.DEPTNO
FROM EMP W, EMP M
WHERE W.MGR = M.EMPNO AND W.MGR IS NOT NULL
ORDER BY DEPTNO;

SELECT DISTINCT JOB, ENAME, EMPNO, DEPTNO
FROM EMP M
WHERE EXISTS (SELECT * FROM EMP WHERE M.EMPNO =MGR); 


-- 26.  말단 사원의 사번, 이름, 업무, 부서번호
SELECT M.EMPNO, M.ENAME, M.JOB, M.DEPTNO
FROM EMP W, EMP M
WHERE W.MGR(+) = M.EMPNO AND W.MGR IS NULL;

SELECT DISTINCT JOB, ENAME, EMPNO, DEPTNO
FROM EMP M
WHERE NOT EXISTS (SELECT * FROM EMP WHERE M.EMPNO=MGR); -- 누군가의 상사번호가 EMPNO가 아닐 때.

SELECT JOB, ENAME, EMPNO, DEPTNO
FROM EMP
WHERE EMPNO NOT IN (SELECT MGR FROM EMP WHERE MGR IS NOT NULL); -- NULL이 아닌 것들을 빼주는 조건을 추가하여 NOT IN을 사용 가능.



SELECT W.ENAME, W.JOB
FROM EMP W, EMP M
WHERE W.MGR = M.EMPNO AND M.ENAME = 'KING';

SELECT * FROM EMP
WHERE (JOB,SAL) IN (SELECT JOB, SAL FROM EMP WHERE ENAME = 'FORD')
AND ENAME != 'FORD';