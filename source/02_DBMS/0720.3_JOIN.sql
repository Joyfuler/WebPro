-- [III] JOIN ; 테이블을 2개 이상 연결해 데이터를 검색하는 방법
-- SCOTT의 모든 데이터를 알고 싶다면?
SELECT * FROM EMP WHERE ENAME = 'SCOTT';
SELECT * FROM DEPT;
-- CROSS JOIN (FROM 절에 테이블을 2개 이상 붙일 때)
SELECT * FROM EMP, DEPT WHERE ENAME = 'SCOTT'; -- 두개를 합치는 과정에서 SCOTT의 값이 1개에서 4개로 불어남.
-- 의미있는 자료를 만들기 위해서는 필드의 값이 같은 것들을 통일해주어야함.
-- 1.★ ★ ★ EQUI JOIN (동등 조인) - 공통필드(DEPTNO)의 값이 일치되는 조건만 JOIN하고자 할 때
SELECT * FROM EMP, DEPT 
WHERE EMP.DEPTNO = DEPT.DEPTNO AND ENAME = 'SCOTT';
-- 크로스 조건은 WHERE 뒤에 두고, WHERE 중에서는 가장 앞에 둘 것. ex) WHERE ~ ~ AND 다른조건
SELECT * FROM EMP, DEPT 
WHERE EMP.DEPTNO = DEPT.DEPTNO;
-- 그러나 DEPTNO와 DEPTNO_1로 불필요한 필드가 2개가 연속으로 나오고 있음.
SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, EMP.DEPTNO AS EMP부서명, DNAME, LOC 
FROM EMP, DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO;
-- 서로 다른 테이블에 같은 이름의 필드가 있는 경우, EMP.DEPTNO 등으로 어떤 테이블에 있는 필드인지를 정의해 주어야함.
-- 필드명 이외에, 필드명도 별칭을 줄 수 있음.
SELECT EMPNO NO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, E.DEPTNO, DNAME, LOC
FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO ORDER BY EMPNO; 
-- 테이블의 별칭이 있을 경우, 원 테이블 명을 사용할 수 없고 별칭을 사용해야 함. (필드와다름)
-- EX. 급여가 2000 이상인 직원만 이름, 직책, 급여, 부서명, 근무지, 부서번호 출력
SELECT ENAME, JOB, SAL, DNAME, LOC, E.DEPTNO FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND SAL>=2000;
-- EX. 20번 부서의 직원만 이름, 부서번호, 근무지 출력
SELECT ENAME, E.DEPTNO, D.LOC FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND D.DEPTNO = 20;
-- EX. 근무지 (LOC) 가 CHICAGO인 사람의 이름, 업무, 급여, 부서번호를 출력
SELECT ENAME, JOB, SAL, D.DEPTNO FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND LOC='CHICAGO';
-- EX. 부서번호가 10이거나 20인 사원의 이름, 업무, 근무지 (급여순) 출력
SELECT ENAME, JOB, LOC FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND E.DEPTNO IN (10,20) ORDER BY SAL;
-- EX. JOB이 SALESMAN이거나 MANAGER인 사원의 이름, 급여, 상여, 연봉(SAL+COMM) * 12, 부서명, 근무지(연봉이 큰 순) 출력
SELECT ENAME, JOB, SAL, COMM, (SAL+NVL(COMM,0)) * 12 AS YEONBONG, DNAME, D.LOC
FROM EMP E, DEPT D 
WHERE E.DEPTNO = D.DEPTNO AND JOB IN ('SALESMAN','MANAGER') ORDER BY YEONBONG DESC;
-- EX. COMM이 NULL이고 SAL이 1200이상인 사원의 이름, 급여, 입사일, 부서번호, 부서명 (부서명순, 급여 큰 순 정렬)
SELECT ENAME, SAL, HIREDATE, E.DEPTNO, DNAME 
FROM EMP E, DEPT D 
WHERE E.DEPTNO=D.DEPTNO AND COMM IS NULL AND SAL >= 1200 ORDER BY DNAME, SAL DESC;
--? 탄탄 다지기
--­	뉴욕에서 근무하는 사원의 이름과 급여를 출력하시오
SELECT ENAME, SAL 
FROM EMP E, DEPT D 
WHERE E.DEPTNO=D.DEPTNO AND D.LOC = 'NEW YORK';
--­	ACCOUNTING 부서 소속 사원의 이름과 입사일을 출력하시오
SELECT ENAME, HIREDATE 
FROM EMP E, DEPT D 
WHERE E.DEPTNO=D.DEPTNO AND DNAME='ACCOUNTING';
--­	직급이 MANAGER인 사원의 이름, 부서명을 출력하시오
SELECT ENAME, DNAME 
FROM EMP E, DEPT D 
WHERE E.DEPTNO=D.DEPTNO AND JOB='MANAGER';
--­	Comm이 null이 아닌 사원의 이름, 급여, 부서코드, 근무지를 출력하시오.
SELECT ENAME, SAL, E.DEPTNO, LOC 
FROM EMP E, DEPT D 
WHERE E.DEPTNO=D.DEPTNO AND COMM IS NOT NULL;

-- 2. NON EQUI JOIN : 같은 것을 물어보지 않음. 같은 것이 X일 때...
SELECT * FROM EMP WHERE ENAME = 'SCOTT' ; -- SALL이 3천.. 급여등급은 몇등급인지?
SELECT * FROM SALGRADE; -- SALGRADE를 확인한 결과 2001~3000 사이에 있는 4등급임.
SELECT * FROM EMP, SALGRADE WHERE ENAME = 'SCOTT'; -- CROSS JOIN (EMP의 1행 * SALGRADE의 5행이 곱해져 5줄이나 출력...)
SELECT * FROM EMP, SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL AND ENAME = 'SCOTT';   -- 낮은순~높은순 주의
-- SAL이라는 값이 LOSAL과 HISAL 사이에 있을 때 출력.
-- EX. 모든 사원의 사번, 이름, 직책, 상사사번, 급여, 급여등급(1등급,2등급, ...)
SELECT EMPNO, ENAME, JOB, MGR, SAL, GRADE||'급' AS GRADE 
FROM EMP, SALGRADE 
WHERE SAL BETWEEN LOSAL AND HISAL;
-- 혹은 SAL >= LOSAL AND SAL <=HISAL;
--	Comm이 null이 아닌 사원의 이름, 급여, 등급, 부서번호, 부서이름, 근무지를 출력하시오.
SELECT ENAME, SAL, GRADE, EMP.DEPTNO, DNAME, LOC 
FROM EMP, DEPT, SALGRADE 
WHERE EMP.DEPTNO=DEPT.DEPTNO AND SAL BETWEEN LOSAL AND HISAL AND COMM IS NOT NULL;
-- 만일 두 가지가 같으면, 중복되지 않은 값만 가져옴
--	이름, 급여, 입사일, 급여등급
SELECT ENAME, SAL, HIREDATE, GRADE FROM EMP, SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL;
--	이름, 급여, 급여등급, 연봉, 부서명, 부서별 출력, 부서가 같으면 연봉순. 연봉=(sal+comm)*12 comm이 null이면 0
SELECT ENAME, SAL, GRADE, (SAL+NVL(COMM,0))* 12 YEONBONG, DNAME 
FROM DEPT, EMP, SALGRADE 
WHERE DEPT.DEPTNO=EMP.DEPTNO AND SAL BETWEEN LOSAL AND HISAL ORDER BY DNAME, YEONBONG DESC;
---	이름, 업무, 급여, 등급, 부서코드, 부서명 출력. 급여가 1000~3000사이. 정렬조건 : 부서별, 부서같으면 업무별, 업무같으면 급여 큰순
SELECT ENAME, JOB, SAL, GRADE, DEPT.DEPTNO, DNAME 
FROM EMP,DEPT, SALGRADE
WHERE DEPT.DEPTNO=EMP.DEPTNO AND (SAL BETWEEN LOSAL AND HISAL) 
AND SAL BETWEEN 1000 AND 3000 ORDER BY DNAME, JOB, SAL DESC;
---	이름, 급여, 등급, 입사일, 근무지. 81년에 입사한 사람. 등급 큰순
SELECT ENAME, SAL, GRADE, HIREDATE, LOC
FROM EMP, DEPT, SALGRADE
WHERE DEPT.DEPTNO=EMP.DEPTNO AND (SAL BETWEEN LOSAL AND HISAL) 
AND TO_CHAR(HIREDATE, 'RR') LIKE '81' ORDER BY GRADE DESC;

-- 3. SELF JOIN
SELECT WORKER.EMPNO, WORKER.ENAME, WORKER.MGR, MANAGER.EMPNO, MANAGER.ENAME
FROM EMP WORKER, EMP MANAGER
WHERE WORKER.ENAME='SMITH'; -- 크로스조인.. SMITH라는 이름에 모든 사원이 다 달라붙었음.
SELECT W.ENAME, W.MGR, M.EMPNO, M.ENAME FROM EMP W, EMP M WHERE W.ENAME='SMITH' AND W.MGR=M.EMPNO;
-- EX. 모든 사원의 사번, 이름, 상사의 사번, 상사의 이름
SELECT W.EMPNO, W.ENAME, W.MGR, M.EMPNO, M.ENAME
FROM EMP W, EMP M
WHERE W.MGR=M.EMPNO; -- 단, 상사가 없는 경우 MGR은 (null)로 나옴. EMPNO가 NULL인 사람은 없으므로 1명은 출력이 안됨.
-- EX. 'SMITH'의 상사는 FORD다' 포맷으로 13명 출력
SELECT W.ENAME||'의 상사는 '||M.ENAME||'이다.' AS MSG
FROM EMP W, EMP M
WHERE W.MGR=M.EMPNO; -- 상사번호는 상사의 사번과 동일하므로...
-- 탄탄. 매니저가 KING인 사원들의 이름과 직급을 출력하시오.
SELECT W.ENAME, W.JOB, M.ENAME SANGSANAME
FROM EMP W, EMP M
WHERE W.MGR=M.EMPNO AND M.ENAME='KING';

-- SCOTT과 동일한 부서번호에서 근무하는 사원의 이름을 출력하시오
SELECT M.ENAME
FROM EMP W, EMP M, DEPT
WHERE W.DEPTNO=DEPT.DEPTNO AND W.DEPTNO=M.DEPTNO AND W.ENAME ='SCOTT' AND M.ENAME != W.ENAME;
-- 중복되는 아이디를 지우기 위해 M.ENAME != W.ENAME을 사용하였음.

-- SCOTT과 동일한 근무지에서 근무하는 사원의 이름을 출력하시오(2단계 최종문제)
SELECT M.ENAME
FROM EMP W, EMP M, DEPT WW, DEPT MM
WHERE W.DEPTNO=WW.DEPTNO AND M.DEPTNO=MM.DEPTNO
AND WW.LOC=MM.LOC AND W.ENAME = 'SCOTT'
AND M.ENAME != W.ENAME;
 -- 같은 이름 중복을 방지하기 위해 != NAME 꼭 넣어주기!

-- DEPT 테이블의 50부서를 입력. (50부서는 DALLAS 근무지로 추가)
SELECT * FROM DEPT;
INSERT INTO DEPT VALUES (50, 'IT', 'DALLAS');
-- EMP 테이블의 DEPTNO 50을 추가.(결론: DALLAS가 근무지인 부서번호: 20,50)
SELECT * FROM EMP ;
INSERT INTO EMP VALUES (8000, '홍길동', NULL, NULL, NULL, 800, NULL, 50);

SELECT * FROM EMP WHERE ENAME= 'SCOTT';
SELECT * FROM DEPT WHERE DEPTNO=20;
SELECT * FROM DEPT;
-- 데이터 원상복귀.. (DEPT 50번 INSERT, EMP 8000번 사원 INSERT)
ROLLBACK;

-- 4. OUTER JOIN : SELF JOIN이나 EQUI JOIN 시 조건에 만족하지 않아 출력되지 않는 행을 나타나게 하는 방법.
-- (1) SELF JOIN에서 OUTER JOIN 하는 방법
-- 제일 높은 상사를 출력하는 방법
SELECT W.ENAME, W.MGR, M.EMPNO, M.ENAME
FROM EMP W, EMP M
WHERE W.MGR = M.EMPNO(+) AND W.ENAME= 'KING';
-- 제일 낮은 직원을 출력하는 방법
SELECT W.ENAME, W.MGR, M.EMPNO, M.ENAME
FROM EMP W, EMP M
WHERE W.MGR(+) = M.EMPNO AND M.ENAME='SMITH';
-- (+)의 위치에 따라 낮은 사람, 혹은 높은 사람을 출력할 수도 있음.
-- EX.
SELECT W.ENAME, W.MGR, M.EMPNO, M.ENAME ENAME2
FROM EMP W, EMP M
WHERE W.MGR = M.EMPNO(+);
-- EX. 'SMITH'의 상사는 '~다' 포맷으로 출력. 'KING의 상사는 없다'
SELECT W.ENAME||'의 상사는 '|| NVL(M.ENAME, '없')|| '다.' AS MSG
FROM EMP W, EMP M
WHERE W.MGR(+) = M.EMPNO;
SELECT W.ENAME, W.MGR, M.EMPNO, M.ENAME
FROM EMP W, EMP M
WHERE W.MGR(+) = M.EMPNO AND W.EMPNO IS NULL;
-- 왼쪽을 하급사원, 오른쪽을 상사로 출력한 뒤 왼쪽 데이터가 없으면(NULL) 해당 부분을 출력하면 됨.

-- (2) EQUI JOIN에서 OUTER JOIN 하는 방법
-- 모두 출력될 것 같지만, 사실은 DEPT 중 DEPTNO의 40번은 보이지 않음. 해당 부서의 직원이 존재하지 않기 때문
SELECT * FROM EMP; -- 14행
SELECT * FROM DEPT; -- 4행.. 2개를 한번에 출력하는 경우, 40번 부서가 없다. 이 역시 해당 값이 없는 쪽에 (+)를 해주면 해결.
SELECT * FROM EMP, DEPT WHERE EMP.DEPTNO(+) = DEPT.DEPTNO;

-- PART 1.

--1. 이름, 직속상사명
SELECT W.ENAME, M.ENAME SANGSA
FROM EMP W, EMP M
WHERE W.MGR=M.EMPNO;
--2. 이름, 급여, 업무, 직속상사명
SELECT W.ENAME, W.SAL, W.JOB, M.ENAME AS SANGSA
FROM EMP W, EMP M
WHERE W.MGR = M.EMPNO;
--3. 이름, 급여, 업무, 직속상사명 . (상사가 없는 직원까지 전체 직원 다 출력.
    --상사가 없을 시 '없음'으로 출력)
SELECT W.ENAME, W.SAL, W.JOB, NVL(M.ENAME,'없음') AS SANGSA
FROM EMP W, EMP M
WHERE W.MGR = M.EMPNO(+);
--4. 이름, 급여, 부서명, 직속상사명
SELECT W.ENAME, W.SAL, DNAME, M.ENAME AS SANGSA
FROM EMP W, EMP M, DEPT D
WHERE W.DEPTNO= D.DEPTNO AND W.MGR = M.EMPNO;
--5. 이름, 급여, 부서코드, 부서명, 근무지, 직속상사명, (상사가 없는 직원까지 전체 직원 다 출력)
SELECT W.ENAME, W.SAL, D.DEPTNO, DNAME, D.LOC, M.ENAME AS SANGSA
FROM EMP W, EMP M, DEPT D
WHERE W.DEPTNO=D.DEPTNO AND W.MGR=M.EMPNO(+);
--6. 이름, 급여, 등급, 부서명, 직속상사명. 급여가 2000이상인 사람
SELECT W.ENAME, W.SAL, S.GRADE, DNAME, M.ENAME AS SANGSA
FROM EMP W, EMP M, DEPT D, SALGRADE S
WHERE  W.DEPTNO=D.DEPTNO AND W.MGR=M.EMPNO(+) AND W.SAL BETWEEN LOSAL AND HISAL AND W.SAL >=2000;
--7. 이름, 급여, 등급, 부서명, 직속상사명, (직속상사가 없는 직원까지 전체직원 부서명 순 정렬)
SELECT W.ENAME, W.SAL, S.GRADE, NVL(M.ENAME,'없어') AS SANGSA
FROM EMP W, EMP M, DEPT D, SALGRADE S
WHERE W.DEPTNO=D.DEPTNO AND W.MGR=M.EMPNO(+) AND W.SAL BETWEEN LOSAL AND HISAL ORDER BY DNAME;
--8. 이름, 급여, 등급, 부서명, 연봉, 직속상사명. 연봉=(급여+comm)*12 단 comm이 null이면 0
SELECT W.ENAME, W.SAL, S.GRADE, DNAME, (W.SAL+ NVL(W.COMM,0))*12 AS YEONBONG, M.ENAME AS SANGSA
FROM EMP W, EMP M, DEPT D, SALGRADE S
WHERE W.DEPTNO=D.DEPTNO AND W.MGR=M.EMPNO AND W.SAL BETWEEN LOSAL AND HISAL;
--9. 8번을 부서명 순 부서가 같으면 급여가 큰 순 정렬
SELECT W.ENAME, W.SAL, S.GRADE, DNAME, ((W.SAL+ NVL(W.COMM,0))*12) AS YEONBONG, M.ENAME AS SANGSA
FROM EMP W, EMP M, DEPT D, SALGRADE S
WHERE W.DEPTNO=D.DEPTNO AND W.MGR=M.EMPNO AND W.SAL BETWEEN LOSAL AND HISAL ORDER BY DNAME, YEONBONG DESC;

--  PART2
--1. 모든 사원에 대한 이름, 부서번호, 부서명을 출력하는 SELECT 문장을 작성하여라.
SELECT ENAME, E.DEPTNO, DNAME 
FROM EMP E, DEPT D 
WHERE E.DEPTNO=D.DEPTNO;
--2. NEW YORK에서 근무하고 있는 사원에 대하여 이름, 업무, 급여, 부서명을 출력
SELECT ENAME, JOB, SAL, DNAME 
FROM EMP E, DEPT D 
WHERE E.DEPTNO=D.DEPTNO AND LOC= 'NEW YORK';
--3. 보너스를 받는 사원에 대하여 이름,부서명,위치를 출력
SELECT ENAME, DNAME, LOC
FROM EMP E, DEPT D 
WHERE E.DEPTNO=D.DEPTNO AND COMM > 0;
-- 보너스를 받으므로, COMM은 0보다 커야함.
--4. 이름 중 L자가 있는 사원에 대하여 이름,업무,부서명,위치를 출력
SELECT ENAME, JOB, DNAME, LOC 
FROM EMP E, DEPT D 
WHERE E.DEPTNO=D.DEPTNO AND ENAME LIKE ('%L%');
--5. 사번, 사원명, 부서코드, 부서명을 검색하라. 사원명기준으로 오름차순정열
SELECT EMPNO, ENAME, E.DEPTNO, DNAME 
FROM EMP E, DEPT D 
WHERE E.DEPTNO=D.DEPTNO ORDER BY ENAME;
--6. 사번, 사원명, 급여, 부서명을 검색하라. 
    --단 급여가 2000이상인 사원에 대하여 급여를 기준으로 내림차순으로 정열하시오
SELECT EMPNO, ENAME, SAL, DNAME 
FROM EMP E, DEPT D 
WHERE E.DEPTNO=D.DEPTNO AND SAL >=2000 ORDER BY SAL DESC;
--7. 사번, 사원명, 업무, 급여, 부서명을 검색하시오. 단 업무가 MANAGER이며 급여가 2500이상인
-- 사원에 대하여 사번을 기준으로 오름차순으로 정열하시오.
SELECT EMPNO, ENAME, JOB, SAL, DNAME 
FROM EMP E, DEPT D 
WHERE E.DEPTNO=D.DEPTNO AND ( JOB = 'MANAGER' AND SAL>=2500) ORDER BY EMPNO;
--8. 사번, 사원명, 업무, 급여, 등급을 검색하시오. 단, 급여기준 내림차순으로 정렬하시오
SELECT EMPNO, ENAME, JOB, SAL, S.GRADE
FROM EMP E, SALGRADE S WHERE SAL BETWEEN LOSAL AND HISAL ORDER BY SAL DESC;
--9. 사원테이블에서 사원명, 사원의 상사를 검색하시오(상사가 없는 직원까지 전체)
SELECT W.ENAME, NVL(M.ENAME,'없어') AS SANGSA
FROM EMP W, EMP M
WHERE W.MGR= M.EMPNO(+);
--10. 사원명, 상사명, 상사의 상사명을 검색하시오
SELECT A.ENAME, B.ENAME AS SANGSA, C.ENAME AS SANGSAOFSANGSA
FROM EMP A, EMP B, EMP C
WHERE A.MGR=B.EMPNO AND B.MGR=C.EMPNO(+);
--11. 위의 결과에서 상위 상사가 없는 모든 직원의 이름도 출력되도록 수정하시오
SELECT A.ENAME, NVL(B.ENAME,'없어') AS SANGSA, NVL(C.ENAME,'없어') AS SANGSAOFSANGSA
FROM EMP A, EMP B, EMP C
WHERE A.MGR=B.EMPNO(+) AND B.MGR=C.EMPNO(+);


