인터페이스 - 프로젝트 단위에서의 기본 설계도. (이런 메소드를 짜야 한다라는 작업 명세서)
인터페이스에는 추상메소드와 final 변수만 들어감.  따라서 private를 사용할 수 없음.
(외부에서 추상메소드를 상속(?)받아 사용해야 하는데, private라면 사용이 불가능)

기본적으로 static이자 final이므로 인터페이스에선 public CONSTANT_NUM = 10; 형식으로 사용. 
(static / final) 사용하지 않음. 상수이므로 외부 수정 역시 불가.
단, static, default 일반 메소드는 사용 가능 (예외 - oracle사에서 배포한 것에 종종 있음)

추상 메소드 역시 public void method1(); 등으로 (abstract)를 생략할 수 있음. (인터페이스 메소드는 무조건 추상메소드이므로)

클래스 간의 상속(extends)과, 인터페이스-클래스를 통한 implements(구현)의 차이는?
상속은 부모 클래스의 기능을 그대로 물려받아 사용할 수 있지만, 인터페이스는 추상 메소드만 있으므로 그대로 상속받아 쓸 수 없음.
(인터페이스 - 인터페이스간에는 상속이 가능함. (둘 다 추상클래스만 있기 때문)
클래스 간 상속은 하나만 가능. (다중상속이 불가) 단 클래스가 implements할 떄는 여러개의 인터페이스를 대상으로 가능.
인터페이스는 객체화가 불가능. (Interface itf = new Interface(); ) - (추상클래스와 마찬가지로 익명의 클래스를 생성해준다면 가능하나, 널리 사용되진 않음)
대신 implements한 클래스를 객체로 생성한다. Class obj = new Class(); 로 객체를 만들면 인터페이스에 있던 추상메소드를 구현 가능.
인터페이스 역시 객체처럼 다형성이 가능. 타입을 변경하면 해당 타입 아래에 있는 명령문만을 수행하고, 다른 것을 수행할 수 없기도 함.
상속과 구현이 모두 발생하는 경우는 extends를 먼저 쓸 것. ex) class test extends test1 implements t11{}

//
인터페이스를 먼저 확인한 후 어떤 메소드를 만들어야 할 지 체크, 혹은 상수를 먼저 볼 것.
